#!/usr/bin/env bash

function tmux-connect {
    TERM=xterm-256color ssh -p ${3:-22} $1@$2 -t "tmux new-session -s $1 || tmux attach-session -t $1"
}

function touchp() {
  for arg
  do
    baseDir=${arg%/*}

    if ! { [ "$arg" = "$baseDir" ] || [ -d "$baseDir" ];}; then
      mkdir -p "${arg%/*}"
    fi

    touch "$arg"
  done
}

function y() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
	yazi "$@" --cwd-file="$tmp"
	if cwd="$(command cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
		builtin cd -- "$cwd"
	fi
	rm -f -- "$tmp"
}

# Detect the appropriate development command based on project files
function detect_dev_command() {
  local project_path="$1"

  if [ -f "$project_path/bun.lockb" ]; then
    echo "bun run dev"
  elif [ -f "$project_path/pnpm-lock.yaml" ]; then
    echo "pnpm run dev"
  elif [ -f "$project_path/yarn.lock" ]; then
    echo "yarn run dev"
  elif [ -f "$project_path/package-lock.json" ]; then
    echo "npm run dev"
  elif [ -f "$project_path/deno.json" ] || [ -f "$project_path/deno.jsonc" ]; then
    echo "deno task dev"
  else
    echo "clear"
  fi
}

# Get the session name from path if not provided
function get_session_name() {
  local base_path="$1"
  local provided_name="$2"

  if [ -z "$provided_name" ]; then
    basename "$base_path"
  else
    echo "$provided_name"
  fi
}

# Display the tmux tree layout
function tmux_tree() {
	# Usage: tmux_tree [session_name_to_highlight]
	local target_name="$1"

	tmux ls -F '#{session_id}' | while IFS= read -r s; do
		# Get full "id + name + tree format" for the session, then strip the id prefix
		local S session_info session_name
		S=$(tmux ls -F '#{session_id}#{session_name}: #{T:tree_mode_format}' | grep "^${s}") || continue
		session_info="${S##${s}}"
		session_name=$(printf '%s' "$session_info" | cut -d ':' -f 1)

		if [[ -n "$target_name" && "$target_name" == "$session_name" ]]; then
			# Bold blue for the chosen session
			printf '\033[1;34m%s\033[0m\n' "$session_info"
		else
			# Bold for other sessions
			printf '\033[1m%s\033[0m\n' "$session_info"
		fi

		# List windows for the session
		tmux lsw -t "$s" -F '#{window_id}' | while IFS= read -r w; do
			local W
			W=$(tmux lsw -t "$s" -F '#{window_id}#{T:tree_mode_format}' | grep "^${w}") || continue
			printf '  ï¬Œ %s\n' "${W##${w}}"
		done
	done
}

# Configure the tmux window layout and commands
function setup_tmux_layout() {
  local session_name="$1"
  local base_path="$2"
  local dev_command="$3"
  local target_window="${session_name}:1"

  # Rename the first window
  tmux rename-window -t "${session_name}:1" "$session_name"

  # Create a new pane with the dev command
  tmux split-window -h -t "$target_window" -c "$base_path"

  # Select the first pane and wait for shell initialization
  tmux select-pane -t "$target_window.2"

  # Send dev command to second pane
  tmux send-keys -t "$target_window.1" "$dev_command" Enter

  # Open VS Code in first pane
  tmux send-keys -t "$target_window.2" "code . && clear" Enter
}

# Handle tmux session attachment
function attach_to_session() {
  local session_name="$1"

  if [ -n "$TMUX" ]; then
    tmux switch-client -t "$session_name"
  else
    tmux attach-session -t "$session_name"
  fi
}

# Create or attach to tmux session and set it up
function handle_tmux_session() {
  local session_name="$1"
  local base_path="$2"
  local dev_command="$3"

  if tmux has-session -t "$session_name" 2>/dev/null; then
    if [ -n "$TMUX" ]; then
      tmux switch-client -t "$session_name"
      setup_tmux_layout "$session_name" "$base_path" "$dev_command"
    else
      tmux attach -t "$session_name"
      setup_tmux_layout "$session_name" "$base_path" "$dev_command"
    fi
  else
    tmux new-session -d -s "$session_name" -c "$base_path"
    setup_tmux_layout "$session_name" "$base_path" "$dev_command"
    attach_to_session "$session_name"
  fi
}

# Main function
function tms() {
  local base_path="$1"
  local session_name="$2"

  # Validate input
  if [ -z "$base_path" ]; then
    echo "Usage: start_tmux_session [session_name] <path>"
    return 1
  fi

  # Initialize session variables
  session_name=$(get_session_name "$base_path" "$session_name")
  local dev_command=$(detect_dev_command "$base_path")

  # Create/attach to session and set up layout
  handle_tmux_session "$session_name" "$base_path" "$dev_command"
}

print-colors() {
  local X=$(tput op)
  local Y=$(printf %$((COLUMNS-6))s)
  for i in {0..256}; do
  o=00$i;
  echo -e ${o:${#o}-3:3} $(tput setaf $i;tput setab $i)${Y// /=}$X;
  done
}

meteo() {
  local LOCALE=$(echo ${LANG:-en} | cut -c1-2)
  if [ $# -eq 0 ]; then
    Local LOCATION=$(curl -s ipinfo.io/loc)
  else
    local LOCATION=$1
  fi
  curl -s "$LOCALE.wttr.in/$LOCATION"
}

command-exists() {
    local exists=$(command -v "$1")
    # command does not exist
    if [[ -z $exists ]]; then
        echo 0
    else # command exists
        echo 1
    fi
}

# Commit using commitizen
gcc() {
  if [[ $(command-exists "git-cz") -eq 0 ]]; then
    npm install --global commitizen
  fi
  git-cz
}

glas() {
  local branch

  # AWK script to format file changes with colors
  local awk_format_files='
  {
    # Parse git diff output
    if ($1 == "-" && $2 == "-") {
      file = $3
    } else {
      added = $1
      deleted = $2
      file = $3
    }

    # Check if file is an image (push to end)
    is_image = (file ~ /\.(png|jpg|jpeg|gif|svg|webp|bmp|ico|tiff)$/)
    sort_key = (is_image ? "1" : "0") "\t" file

    # Format output with colors
    if ($1 == "-" && $2 == "-") {
      printf "%s\t\033[36mR  %s\033[0m\n", sort_key, file
    } else if (added == "0" && deleted > 0) {
      printf "%s\t\033[31mD  -%s %s\033[0m\n", sort_key, deleted, file
    } else if (deleted == "0" && added > 0) {
      printf "%s\t\033[32mA  +%s %s\033[0m\n", sort_key, added, file
    } else {
      printf "%s\t\033[33mM  +%s -%s %s\033[0m\n", sort_key, added, deleted, file
    }
  }'

  # Build the preview command
  local preview_cmd='
    BRANCH=$(echo {1} | sed "s/\x1b\[[0-9;]*m//g")
    BASE=$(git rev-parse --verify main 2>/dev/null && echo "main" || echo "master")

    echo "Branch: $BRANCH"
    echo

    git log --oneline --color=always -n 5 "$BRANCH"
    echo

    echo "Changed files from $BASE:"
    echo

    git diff --numstat "$BASE"..."$BRANCH" 2>/dev/null \
      | awk '"'"''"${awk_format_files}"''"'"' \
      | sort -k1,2 \
      | cut -f3- \
      | head -100

    echo
    git diff --stat --color=always "$BASE"..."$BRANCH" 2>/dev/null | tail -1 \
      || echo "No changes from $BASE"
  '

  # Get list of branches and let user select with fzf
  branch=$(git for-each-ref \
    --sort=-committerdate \
    refs/heads/ \
    --format='%(color:yellow)%(refname:short)%(color:reset)' \
    | fzf --ansi \
      --preview-window=right:50%:wrap \
      --preview "$preview_cmd"
  ) || return

  # Clean ANSI codes and switch to selected branch
  branch=$(echo "$branch" | sed 's/\x1b\[[0-9;]*m//g')
  git switch "$branch"
}
